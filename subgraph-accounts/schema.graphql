extend schema
  @link(url: "https://specs.apollo.dev/federation/v2.7",
  import: ["@key","@shareable"])

# SCALARS
scalar DateTime

# OBJECTS

type Account @key(fields: "id") {
  "The unique ID associated with the account."
  id: ID!
  "The date and time the account was created."
  createdAt: DateTime!
  "The email associated with the account (must be unique)."
  email: String!
}

type AuthPayload {
  "The user's JWT"
  token: String!
  "The user's ID"
  userId: ID!
}

"Represents an Airlock user's common properties"
interface User @key(fields: "id") {
  id: ID!
  "The user's first and last name"
  name: String!
  "The user's role"
  role: Role!
  "The user's profile photo URL"
  picture: String!
  "The email address of the user (must be unique)."
  email: String!
  "The nickname of the user"
  nickname: String!
  "The listings of the user"
  listings: [Listing]!
}

type Host implements User @key(fields: "id") {
  id: ID!
  "The user's first and last name"
  name: String! 
  "The user's profile photo URL"
  picture: String! 
  "The host's profile bio description, will be shown in the listing"
  description: String 
  "The email address of the user (must be unique)."
  email: String!
  "The user's chosen nickname (must be unique)."
  nickname: String!
  "The role of the user"
  role: Role!
  "The listings of the user"
  listings: [Listing]!
}

enum Role {
  ADMIN
  GUEST
  HOST
}

type Guest implements User @key(fields: "id") {
  "The unique ID associated with the account."
  id: ID!
  "The user's first and last name"
  name: String! 
  "The user's profile photo URL"
  picture: String! 
  "The email address of the user (must be unique)."
  email: String!
  "The user's chosen nickname (must be unique)."
  nickname: String!
  "The role of the user"
  role: Role!
  "The bookings of the user"  
  bookings: [Booking]! 
  "the listings of the user booked"
  listings: [Listing]! 
}

interface Response {
  "Similar to HTTP status code, represents the status of the mutation"
  code: Int!
  "Indicates whether the mutation was successful"
  success: Boolean!
  "Human-readable message for the UI"
  message: String!
}

"""
Provides data to update an existing account's email.
"""
input UpdateAccountEmailInput {
  "The unique ID associated with the account."
  id: ID!
  "The updated account email."
  email: String!
}

"""
Provides data to update an existing account's password. A current password and new password are required to update a password.
"""
input UpdateAccountPasswordInput {
  "The unique ID associated with the account."
  id: ID!
  "The updated account password."
  newPassword: String!
  "The existing account password."
  password: String!
}



"""
Provides data to create a new account.
"""
input CreateAccountInput {
  "The new account's email (must be unique)."
  email: String!
  "The new account's password."
  password: String!
}

type Booking @key(fields: "id") {
  id: ID!
  "The unique ID associated with the bookings."
  guestId: ID!
  "The date and time the booking was created."
  createdAt: DateTime
  "The date and time the booking was cancelled."
  cancelledAt: DateTime
  "The date and time the booking was confirmed."
  confirmedAt: DateTime
  "The unique ID associated with the listingsId"
  listingId: ID! 
}

type Listing @key(fields: "id") {
  "The unique ID associated with the listing."
  id: ID!
  "The title of the listing."
  title: String!
  "The description of the listing."
  description: String!
  "The price of the listing."
  price: Float!
  "The host of the listing."
  hostId: ID!
  "The location of the listing."
  location: Location!
  "The latitude of the listing."
  latitude: Float!
  "The longitude of the listing."
  longitude: Float!
}

type Location @key(fields:"id") {
  "The unique ID associated with the location"
  id: Int! 
  "The name of the address"
  name: String! 
  "The address of the location"
  address: String! 
  "The city of the location"
  city: String! 
  "The state of the location"
  state: String! 
  "The zip code of the location"
  zip: String! 
  "The listings of the location"
  listings: [Listing] 
}

interface Node {
  "The node's ID"
  id: ID!
}

type _Service {
  sdl: String
}

type UserId {
  id: ID!
}

scalar _Any

union _Entity = Listing | Host | Guest | Generator | Booking

type Query {
  getUser(id: String!): User
  listings: [Listing] 
  "User accounts"
  user(id: ID!): User 
  "Currently logged-in user"
  me: User! 
  "Retrieves the account of the currently logged-in user."
  viewer: Account
  "The booking of the currently user"
  bookings: [Booking] 
  "Retrieves the account of the currently logged-in user."
  account(id: ID!): Account 
  "Retrieves the accounts of the currently logged-in user."
  accounts: [Account] 
  "Fetch bookings for a specific user"
  bookingsByUser(userId: ID!): [Booking]
  "Fetch a booking by its ID"
  bookingById(id: ID!): Booking
}

type Generator @key(fields: "id") {
  id: ID!
  name: String!
  description: String
  createdAt: DateTime!
  createdBy: User!
  isActive: Boolean!
  getUser(id: ID!): User
  createUser(input: CreateUserInput): User
}

input UpdateUserInput {
  "The user's first and last name"
  name: String

  "The user's profile photo URL"
  picture: String

  "The email address of the user (must be unique)."
  email: String

  "The user's chosen nickname (must be unique)."
  nickname: String
}

extend type Mutation {
  createUser(name: String!, email: String!, password: String!): User
  createListing(title: String!, description: String!, price: Float, locationId: Int, hostId: String): Listing
  "Creates a new Guest user." 
  createAccount(input: CreateAccountInput!): Account!
  "Deletes an account."
  deleteAccount(id: ID!): Boolean!
  "Updates an account's email."
  updateAccountEmail(input: UpdateAccountEmailInput!): Account!
  "Updates an account's password."
  updateAccountPassword(input: UpdateAccountPasswordInput!): Account!
  "Research listing information according to hostId."
  researchListing(hostId: ID!): [Listing!]!

  "Research booking information according to guestId."
  researchBooking(guestId: ID!): [Booking!]!

  "Guest confirms the status of booking."
  confirmBooking(id: ID!): Boolean!

  "Guest cancels the status of booking."
  cancelBooking(id: ID!): Boolean!

  "Host confirms the status of listing."
  confirmListing(id: ID!): Boolean!

  "Host cancels the status of listing."
  cancelListing(id: ID!): Boolean!

  # Additional mutations for user management
  "Update user information."
  updateUser(id: ID!, input: UpdateUserInput!): User

  "Delete a user."
  deleteUser(id: ID!): Boolean!

}

input CreateUserInput {
  "the name of user"
  name: String!
  "the email of user"
  email: String!
  "the password of user"
  password: String!
}

input CreateListingInput {
  "the title of listing"
  title: String!
  "the description of listing"
  description: String
  "the price of listing"
  price: Float!
  "the id of location"
  locationId: String!
  "the id of host"
  hostId: String!
}

