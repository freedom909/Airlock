extend schema
  @link(
    url: "https://specs.apollo.dev/federation/v2.4"
    import: ["@key", "@shareable", "@override","@provides"]
)

# SCALARS
scalar DateTime
# OBJECTS

extend type Query {
  "User accounts"
  user(id: ID!): User @shareable
  "Currently logged-in user"
  me: User! @shareable
  #   "Retrieves a single account by ID."
  # account(id: ID!): Account! @private
  # "Retrieves a list of accounts."
  # accounts: [Account] @private
  "Retrieves the account of the currently logged-in user."
  viewer: Account
  bookings: [Booking] @private
}

type Account @key(fields: "id") {
  "The unique ID associated with the account."
  id: ID!
  "The date and time the account was created."
  createdAt: DateTime!
  "The email associated with the account (must be unique)."
  email: String!
}

type AuthPayload {
  "The user's JWT"
  token: String!
  "The user's ID"
  userId: ID!
}

"Represents an Airlock user's common properties"
interface User {
  id: ID!
  "The user's first and last name"
  name: String!
  "The user's role"
  role: ROLE!
  "the user's password"
  password: String!
  "The user's token"
  token: String
  "the user's refreshed token"
  refresh_token: String
  "The user's profile photo URL"
  picture: String!
  "The email address of the user (must be unique)."
  email: String!
  "The nickname of the user"
  nickname: String!
  "The listings of the user"
  listing: [Listing]
}

type Host implements User @key(fields: "id") {
  id: ID!
  "The user's first and last name"
  name: String! @shareable
  "The user's profile photo URL"
  picture: String! @shareable
  "The host's profile bio description, will be shown in the listing"
  description: String @shareable
  "The email address of the user (must be unique)."
  email: String!
  "The password of the user"
  password: String!
  "The user's chosen nickname (must be unique)."
  nickname: String
  "The role of the user"
  role: Role
  "the listings of the user"
  listing: [Listing]!
}

enum Role {
  ADMIN
  GUEST
  HOST
}

type Guest implements User @key(fields: "id") {
  "The unique ID associated with the account."
  id: ID!
  "The user's first and last name"
  name: String! @shareable
  "The user's profile photo URL"
  picture: String! @shareable
  "The email address of the user (must be unique)."
  email: String!
  "The password of the user"
  password: String!
  "The user's chosen nickname (must be unique)."
  nickname: String!
  "The role of the user"
  role: Role 
  "The bookings of the user"  
  bookings: [Booking]
}
 


interface MutationResponse {
  "Similar to HTTP status code, represents the status of the mutation"
  code: Int!
  "Indicates whether the mutation was successful"
  success: Boolean!
  "Human-readable message for the UI"
  message: String!
}

"The response after updating a profile"
type UpdateProfileResponse implements MutationResponse {
  "Similar to HTTP status code, represents the status of the mutation"
  code: Int!
  "Indicates whether the mutation was successful"
  success: Boolean!
  "Human-readable message for the UI"
  message: String!
  "Updated user"
  user: User @shareable
}

"""
Provides data to update an existing account's email.
"""
input UpdateAccountEmailInput {
  "The unique ID associated with the account."
  id: ID!
  "The updated account email."
  email: String!
}

"""
Provides data to update an existing account's password. A current password and new password are required to update a password.
"""
input UpdateAccountPasswordInput {
  "The unique ID associated with the account."
  id: ID!
  "The updated account password."
  newPassword: String!
  "The existing account password."
  password: String!
}

"Fields that can be updated"
input UpdateProfileInput {
  "The user's first and last name"
  name: String
  "The user's profile photo URL"
  picture: String
  "The host's profile bio description, will be shown in the listing"
  profileDescription: String
}

type Mutation {
  "Updates the logged-in user's profile information"
  updateProfile(updateProfileInput: UpdateProfileInput): UpdateProfileResponse!@shareable
  "Authenticates an existing user."
  signIn(email: String!, password: String!): AuthPayload!
  "Logs an authenticated user out."
  logout: Boolean!
  "Creates a new Guest user."
  signUp(input: SignUpInput!): AuthPayload!
    "Creates a new account."
  createAccount(input: CreateAccountInput!): Account!
  # "Deletes an account."
  # deleteAccount(id: ID!): Boolean! @scope(permissions: ["delete:accounts"])
  # "Updates an account's email."
  # updateAccountEmail(input: UpdateAccountEmailInput!): Account!
  #   @owner(argumentName: "input.id")
  # "Updates an account's password."
  # updateAccountPassword(input: UpdateAccountPasswordInput!): Account!
  # @owner(argumentName: "input.id")
}

 """
  Provides data to create a new account.
  """
  input CreateAccountInput {
    "The new account's email (must be unique)."
    email: String!
    "The new account's password."
    password: String!
  }

input SignUpInput {
  "The email address of the user (must be unique)."
  email: String!
  "The full name of the user."
  name: String!
  """
  The user's chosen password.

  It must be a minimum of 8 characters in length and contain 1 lowercase
  letter, 1 uppercase letter, 1 number, and 1 special character.
  """
  password: String!
  "The user's chosen username (must be unique)."
  nickname: String
  "The user's inviteCode"
  inviteCode: String
  "The user's role"
  role: Role
    "The user's profile photo URL"
  picture: String! 
}

input SignInInput {
  "The email address of the user (must be unique)."
  email: String!
  """
  The user's chosen password.
  It must be a minimum of 8 characters in length and contain 1 lowercase
  letter, 1 uppercase letter, 1 number, and 1 special character.
  """
  password: String!
}

type Booking @key(fields: "id") {
  id: ID!
  "The unique ID associated with the account."
  guestId: ID!
  "The date and time the booking was created."
  createdAt: DateTime!
  "The date and time the booking was cancelled."
  cancelledAt: DateTime
  "The date and time the booking was confirmed."
  confirmedAt: DateTime
  "The date and time the booking was cancelled."
}

type Listing @key(fields: "id") {
 "The unique ID associated with the account."
  id: ID!
 "The title of the listings associated with the account."
  title: String!
  'The list of the description'
  description: String!
  "the price of the listings associated with the account."
  price: Float!
  "the price of the listings"
  location: Location!
  "the host of User"
  host: User!
}

  

